{
  "Name": "OSCReceiver",
  "_id": "5108d91a-4931-436f-9c7f-c0ae352558f0",
  "Namespace": "lib.io.osc",
  "Description": "OSC receiver operator. Outputs an associative array of messages received from last frame, which should be processed by OSCMessage* operators. Usually only a single OSCReceiver is needed, but there could be some complex scenarios when the messages are being received from two or more different UDP ports.\r\n\r\nIf \"OSC Path Prefix\" parameter is not empty, then additional filtering of messages is performed. For example if the prefix is set to \"tooll\", then only messages with path of form /tooll/foo/bar are being put in the output associative array - i.e. accepted, other messages are igored. Moreover, the prefix part will be removed from the path, i.e. /tooll/foo/bar becomes /foo/bar - should be considered in the OSCMessage* \"OSC Path\" parameter.",
  "Inputs": [
    {
      "Name": "UDP Port",
      "MetaInstanceID": "90532db7-2062-495e-8f3d-30b87b57c64a",
      "DefaultValue": {
        "Type": "Text",
        "Value": "9999"
      },
      "MetaID": "c522a66e-3260-4692-b3e3-79fd0361fa3d",
      "IsMultiInput": "False",
      "Relevance": "Required",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "OSC Path Prefix",
      "MetaInstanceID": "0846aa08-4890-458f-9315-688916a91c8b",
      "DefaultValue": {
        "Type": "Text",
        "Value": "tooll"
      },
      "MetaID": "c522a66e-3260-4692-b3e3-79fd0361fa3d",
      "IsMultiInput": "False",
      "Relevance": "Required",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "ShowLogInfo",
      "MetaInstanceID": "de71d716-b8e5-4dc2-bae9-deee73f9857f",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Required",
      "Description": "",
      "Min": "0",
      "Max": "1",
      "Scale": "1",
      "ScaleType": "Linear",
      "EnumValues": [
        {
          "Name": "Off",
          "Value": "0"
        },
        {
          "Name": "On",
          "Value": "1"
        }
      ]
    }
  ],
  "Outputs": [
    {
      "Name": "Messages",
      "MetaInstanceID": "9212a417-d7c5-4ee0-afb8-af4fc209ac8f",
      "MetaID": "9701d534-b3ff-4889-a250-84aece4a7d76"
    }
  ],
  "OperatorParts": [
    {
      "MetaInstanceID": "4b0e9a11-391b-4e1d-b0cb-e2c427a3434b",
      "MetaID": "b3adfc0a-5efe-4127-b2e3-038028022e3a",
      "Name": "OSCReceiverFunc",
      "Version": "b7070937-f0ef-4723-80c1-39095a404bd1",
      "Type": "Float",
      "IsMultiInput": "True",
      "Script": [
        "//>>> _using",
        "using System;",
        "using System.Collections.Generic;",
        "using System.Linq;",
        "using System.Text;",
        "using SharpDX;",
        "using SharpDX.Direct3D11;",
        "using SharpDX.Windows;",
        "//<<< _using",
        "",
        "using System.Collections;",
        "using System.Threading;",
        "using System.Net;",
        "using OSC;",
        "",
        "namespace Framefield.Core.IDb3adfc0a_5efe_4127_b2e3_038028022e3a",
        "{",
        "    public class Class_OSCReceiver : OperatorPart.Function, Framefield.Core.OperatorPartTraits.ITimeAccessor",
        "    {",
        "        //>>> _inputids",
        "        private enum InputId",
        "        {",
        "            UDPPort = 0,",
        "            OSCPathPrefix = 1,",
        "            ShowLogInfo = 2",
        "        }",
        "        //<<< _inputids",
        "        ",
        "        public override void Dispose()",
        "\t\t{",
        "\t\t    //Logger.Debug(this, \"Class_OSCInput.Dispose\");",
        "\t\t\tStopListeningOSC();",
        "\t\t\t",
        "\t\t\tbase.Dispose();",
        "\t\t}",
        "        ",
        "        public override OperatorPartContext Eval(OperatorPartContext context, List<OperatorPart> inputs, int outputIdx) ",
        "        {",
        "            if (Changed)",
        "            {",
        "                //>>> _params",
        "                var UDPPort = inputs[(int)InputId.UDPPort].Eval(context).Text;",
        "                var OSCPathPrefix = inputs[(int)InputId.OSCPathPrefix].Eval(context).Text;",
        "                var ShowLogInfo = (int) inputs[(int)InputId.ShowLogInfo].Eval(context).Value;",
        "                //<<< _params",
        "                ",
        "                // Update UDP port",
        "                int newUDPPort;",
        "                bool res = int.TryParse(UDPPort, out newUDPPort);",
        "            \tif (res == false)",
        "            \t{",
        "            \t    Logger.Error(this, \"Eval: Wrong port string: \" + UDPPort);",
        "            \t}",
        "            \telse if (_UDPPort != newUDPPort)",
        "            \t{",
        "            \t    _UDPPort = newUDPPort;",
        "             ",
        "                \t// Reinitialize the network part",
        "    \t\t\t\tStopListeningOSC();",
        "    \t\t\t\tStartListeningOSC();",
        "    \t\t\t}",
        "    \t\t\t",
        "    \t\t\t_OSCPathPrefix = OSCPathPrefix;",
        "    \t\t\t_showLogInfo = Convert.ToBoolean(ShowLogInfo); // Enum: 0 is Off, 1 is On",
        "            ",
        "                Changed = false;",
        "            }",
        "            ",
        "            // Process the message queue",
        "            lock (_messageQueue)",
        "\t\t\t{",
        "\t\t\t    //if (_debug)",
        "\t\t\t    //    Logger.Debug(this, \"Eval: Processing messages: \" + _messageQueue.Count);",
        "\t\t\t        ",
        "\t\t\t    if (_messageQueue.Count > 0)",
        "\t\t\t    {",
        "\t\t\t\t    foreach (var message in _messageQueue)",
        "\t\t\t\t\t    ProcessOSCMessage(message, context);",
        "\t\t\t\t    _messageQueue.Clear();",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t\t",
        "            // Should always set a new value for the context, even if no messages were processed since last frame",
        "            context.Dynamic = _frameMessages;",
        "            return context;",
        "        }",
        "        ",
        "        private void StartListeningOSC()",
        "\t\t{",
        "\t\t    if (_listening == true || _OSCReceiver != null)",
        "\t\t        return;",
        "            ",
        "            _OSCReceiver = new OSCReceiver(_UDPPort);",
        "            int errorCode;",
        "            bool success = _OSCReceiver.Connect(out errorCode);",
        "            if (success == false)",
        "            {",
        "                Logger.Error(this, \"StartListeningOSC: Connect to port {0} failed, error code: {1}\", _UDPPort, errorCode);",
        "                return;",
        "            }",
        "            ",
        "            if (_debug)",
        "                Logger.Debug(this, \"StartListeningOSC: Connect to port {0} succeded, starting listener thread\", _UDPPort);",
        "    \t\t",
        "    \t\t_listening = true;",
        "\t\t\t_receiverThread = new Thread(new ThreadStart(ListenToOSC));",
        "\t\t\t_receiverThread.Start();",
        "\t\t}",
        "\t\t",
        "\t\tprivate void StopListeningOSC()",
        "\t\t{",
        "\t\t\tif (_receiverThread != null && _receiverThread.IsAlive)",
        "\t\t\t{",
        "\t\t\t\t_listening = false;",
        "\t\t\t\t// _OSCReceiver is blocking the thread",
        "\t\t\t\t// so waiting would freeze",
        "\t\t\t\t// shouldn't be necessary here anyway...",
        "\t\t\t\t//_receiverThread.Join();",
        "\t\t\t}",
        "",
        "\t\t\tif (_OSCReceiver != null)",
        "\t\t\t{",
        "\t\t\t\t_OSCReceiver.Close();",
        "\t\t\t\tif (_debug)",
        "                    Logger.Debug(this, \"StopListeningOSC: Closed UDP port\");",
        "\t\t\t}",
        "\t\t\t_OSCReceiver = null;",
        "\t\t}",
        "\t\t",
        "\t\tprivate void ListenToOSC()",
        "\t\t{",
        "\t\t\twhile (_listening)",
        "\t\t\t{",
        "\t\t\t\ttry",
        "\t\t\t\t{",
        "\t\t\t\t\tOSCPacket packet = _OSCReceiver.Receive();",
        "\t\t\t\t\tif (packet != null)",
        "\t\t\t\t\t{",
        "\t\t\t\t\t    if (_debug)",
        "\t\t\t\t\t       Logger.Debug(this, \"ListenToOSC: received OSC packet\");",
        "\t\t\t\t\t       ",
        "\t\t\t\t\t\tif (packet.IsBundle())",
        "\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\tArrayList messages = packet.Values;",
        "\t\t\t\t\t\t\tlock(_messageQueue)",
        "\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\tfor (int i = 0; i < messages.Count; ++i)",
        "\t\t\t\t\t\t\t\t\t_messageQueue.Add((OSCMessage)messages[i]);",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t\telse",
        "\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\tlock(_messageQueue)",
        "\t\t\t\t\t\t\t{",
        "\t\t\t\t\t\t\t\t_messageQueue.Add((OSCMessage)packet);",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t\t",
        "\t\t\t\t\t\tif (_debug)",
        "\t\t\t\t\t\t    Logger.Debug(this, \"ListenToOSC: number of messages in queue: \" + _messageQueue.Count);",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t\tcatch (Exception ex)",
        "\t\t\t\t{",
        "\t\t\t\t\tLogger.Error(this, \"ListenToOSC: exception caught: \" + ex.Message);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t\t",
        "\t\tprivate string messageToString(OSCMessage message)",
        "\t\t{",
        "\t\t  return Convert.ToString(message);",
        "\t\t}",
        "\t\t",
        "\t\tprivate void ProcessOSCMessage(OSCMessage message, OperatorPartContext context)",
        "\t\t{",
        "            var path = message.Address.Split('/');",
        "            ",
        "            // Ignore messages which don't have a user-defined path prefix",
        "            if (_OSCPathPrefix != String.Empty && path[0] != _OSCPathPrefix)",
        "            {",
        "                if (_showLogInfo)",
        "                    Logger.Info(this, \"Message ignored: {0}\", messageToString(message));",
        "                return;",
        "            }",
        "            ",
        "            if (_showLogInfo)",
        "                Logger.Info(this, \"Message accepted: {0}\", messageToString(message));",
        "            ",
        "            ",
        "            // Trim the prefix from the path: let \"tooll\" be the prefix, then ",
        "            // /tooll/someparam becomes /someparam",
        "            if (_OSCPathPrefix != String.Empty)",
        "            {",
        "                string trimedAddress = \"\";",
        "                for (int i = 1; i < path.Length; ++i)",
        "                {",
        "                    trimedAddress += path[i] + '/';",
        "                }",
        "                message.Address = trimedAddress;",
        "            }",
        " ",
        "            _frameMessages[message.Address] = message;",
        "\t\t}",
        "\t\t",
        "\t\t// Enable/disable printing some additional very verbose debug info to Logger.Debug",
        "\t\tprivate bool _debug = true;",
        "\t\t",
        "\t\t// Input parameters",
        "\t\tprivate int _UDPPort;",
        "\t\tprivate string _OSCPathPrefix;",
        "\t\tprivate bool _showLogInfo;",
        "        ",
        "        // OSCReceiver instance",
        "        private OSCReceiver _OSCReceiver;",
        "        // Whether OSCReceiver is listening to a specified port",
        "        private bool _listening;",
        "        // A thread where listening function lives",
        "        private Thread _receiverThread;",
        "        // A list of messages which haven't been processed yet",
        "        private List<OSCMessage> _messageQueue = new List<OSCMessage>();        ",
        "        // This associative array of messages is being filled with messages from _messageQueue on each frame",
        "        // and passed to OSCMessage* operators as Dynamic value",
        "        private IDictionary<string, OSCMessage> _frameMessages = new Dictionary<string, OSCMessage>();",
        "    }",
        "}",
        "",
        ""
      ],
      "AdditionalAssemblies": [
        "Libs/OSC.dll"
      ]
    }
  ],
  "Operators": [],
  "Connections": [
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "90532db7-2062-495e-8f3d-30b87b57c64a",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "4b0e9a11-391b-4e1d-b0cb-e2c427a3434b"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "0846aa08-4890-458f-9315-688916a91c8b",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "4b0e9a11-391b-4e1d-b0cb-e2c427a3434b"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "de71d716-b8e5-4dc2-bae9-deee73f9857f",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "4b0e9a11-391b-4e1d-b0cb-e2c427a3434b"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "4b0e9a11-391b-4e1d-b0cb-e2c427a3434b",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "9212a417-d7c5-4ee0-afb8-af4fc209ac8f"
    }
  ]
}