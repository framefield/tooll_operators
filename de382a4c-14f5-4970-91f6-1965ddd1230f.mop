{
  "Name": "TwirlDistort",
  "_id": "de382a4c-14f5-4970-91f6-1965ddd1230f",
  "Namespace": "lib.geometry.modify",
  "Description": "GPU-based noise deformer derived from Scatter.\r\n\r\nSee [TwirlExample] to get an idea.",
  "Inputs": [
    {
      "Name": "Code",
      "MetaInstanceID": "00b8b4d9-f0a4-4b07-9c19-018a4358c1f6",
      "DefaultValue": {
        "Type": "Text",
        "Value": [
          "//>>> _parameters\r",
          "float Value;",
          "float3 Center;",
          "float NoiseTime;",
          "float NoiseAmount;",
          "float NoiseScale;",
          "float NoiseScale2;",
          "//<<< _parameters\r",
          "\r",
          "struct Vertex\r",
          "{\r",
          "    float4 pos : POSITION;\r",
          "    float3 normal : NORMAL;\r",
          "    float4 col : COLOR;\r",
          "    float2 texCoord : TEXCOORD0;\r",
          "    float3 tangent : TANGENT0;\r",
          "    float3 binormal : BINORMAL0;\r",
          "};\r",
          "\r",
          "\r",
          "float Noise(int x, int seed)\r",
          "{\r",
          "    int n = x + seed*137;\r",
          "    n = (n << 13) ^ n;\r",
          "    return (float) (1.0 - ((n*(n*n*15731 + 789221) + 1376312589) & 0x7fffffff)/1073741824.0);\r",
          "}\r",
          "\r",
          "float Lerp(float a, float b, float t)\r",
          "{\r",
          "    return a + t*(b - a);\r",
          "}\r",
          "\r",
          "float Fade(float t)\r",
          "{\r",
          "    return t*t*t*(t*(t*6 - 15) + 10);\r",
          "}\r",
          "\r",
          "float SEED= 2323;\r",
          "\r",
          "float getNoise(float value)\r",
          "{\r",
          "    float noiseSum = 0.0f;\r",
          "    value *= NoiseScale;\r",
          "    value += NoiseTime;\r",
          "\r",
          "\r",
          "    noiseSum = Lerp(Noise((int) value, SEED),\r",
          "                    Noise((int) value + 1, SEED),\r",
          "                    Fade(value - (float) floor(value)));\r",
          "    return noiseSum;\r",
          "}\r",
          "\r",
          "\r",
          "\r",
          "\r",
          "Vertex VertexMain(Vertex input)\r",
          "{\r",
          "    return input;\r",
          "}\r",
          "\r",
          "float _noiseTime=0;\r",
          "float _frequency=0;\r",
          "\r",
          "\r",
          "\r",
          "[maxvertexcount(3)]\r",
          "void GeometryMain(triangle Vertex input[3], inout TriangleStream<Vertex> outputStream)\r",
          "{\r",
          "\r",
          "    /*\r",
          "    float3 pCenter = (input[0].pos.xyz + input[1].pos.xyz + input[2].pos.xyz)/3 + Translate;\r",
          "\r",
          "    float randomSeedf= ((input[0].pos.x + input[1].pos.x + input[2].pos.x) / 3 +\r",
          "                (input[0].pos.y + input[1].pos.y + input[2].pos.y) / 3 -\r",
          "                (input[0].pos.z + input[1].pos.z + input[2].pos.z) / 3) * 100;\r",
          "    int seed = (int)randomSeedf;\r",
          "\r",
          "    float3 direction = (pCenter-Center);\r",
          "    float distance = length(direction);            \r",
          "    //float x =   clamp(( Range.y - distance) / Range.x, 0, 1);\r",
          "    float falloff = Range.y;\r",
          "    if (falloff == 0) {\r",
          "        falloff = 0.00001;\r",
          "    }\r",
          "    float x = clamp(- (distance - Range.x)/falloff, 0, 1);\r",
          "    \r",
          "    float influence = x*x*(3 - 2*x);  // SmoothStep\r",
          "\r",
          "\r",
          "    float angleX= influence * 3.141578 * Rotate/360 * getNoise(13, seed);\r",
          "    float cax= cos(angleX);\r",
          "    float sax= sin(angleX);    \r",
          "    float4x4 rotx = {    1,    0,    0,    0,\r",
          "                         0,    cax, -sax,  0,\r",
          "                         0,    sax,  cax,  0,\r",
          "                         0,    0,    0,    1};\r",
          "    float angleY= influence * 3.141578 * Rotate/360 * getNoise(1233, seed);\r",
          "    float cay= cos(angleY);\r",
          "    float say= sin(angleY);    \r",
          "    float4x4 roty = {    cay,  0,    say,  0,\r",
          "                         0,    1,    0,    0,\r",
          "                        -say,  0,    cay,  0,\r",
          "                         0,    0,    0,    1};\r",
          "    float4x4 rotation = mul(rotx,roty);                         \r",
          "                             \r",
          "    float4x4 translateToOrigin ={ 1,    0,    0,   -pCenter.x,\r",
          "                             0,    1,    0,   -pCenter.y,\r",
          "                             0,    0,    1,   -pCenter.z,\r",
          "                             0,    0,    0,   1};\r",
          "\r",
          "    float4x4 translateBack={  1,    0,    0,   pCenter.x,\r",
          "                             0,    1,    0,    pCenter.y,\r",
          "                             0,    0,    1,    pCenter.z,\r",
          "                             0,    0,    0,   1};\r",
          "\r",
          "\r",
          "    float3 offset=  normalize(direction) * influence * ( Push + getNoise(2342, seed) * Scatter );\r",
          "    float4x4 translateOffset={ 1,    0,    0,   offset.x,\r",
          "                               0,    1,    0,   offset.y,\r",
          "                               0,    0,    1,   offset.z, \r",
          "                               0,    0,    0,   1};\r",
          "\r",
          "\r",
          "    \r",
          "    float4x4 transform = translateToOrigin;\r",
          "    transform = mul( rotation, transform);\r",
          "    transform = mul( translateBack, transform);\r",
          "    transform = mul( translateOffset, transform);\r",
          "    */\r",
          "/*\r",
          "    Vertex v0 = input[0];\r",
          "    Vertex v1 = input[1];\r",
          "    Vertex v2 = input[2];\r",
          "    \r",
          "    v0.pos.xyz += float3(getNoise((v0.pos.y+v0.pos.z) * NoiseScale - 6.3f), \r",
          "                     getNoise((v0.pos.z) * NoiseScale + 9.3f), \r",
          "                     getNoise((v0.pos.x) * NoiseScale - 0.3f)) * NoiseAmount;\r",
          "\r",
          "    v1.pos.xyz += float3(getNoise((v1.pos.y+v1.pos.z) * NoiseScale - 6.3f), \r",
          "                         getNoise((v1.pos.z) * NoiseScale + 9.3f), \r",
          "                         getNoise((v1.pos.x) * NoiseScale - 0.3f)) * NoiseAmount;\r",
          "    v2.pos.xyz += float3(getNoise((v2.pos.y+v2.pos.z) * NoiseScale - 6.3f), \r",
          "                     getNoise((v2.pos.z) * NoiseScale + 9.3f), \r",
          "                     getNoise((v2.pos.x) * NoiseScale - 0.3f)) * NoiseAmount;\r",
          "\r",
          "    float3 n= cross( v1.pos-v0.pos, v2.pos-v0.pos); \r",
          "    v0.normal =n;\r",
          "    v1.normal =n;\r",
          "    v2.normal =n;\r",
          "                     \r",
          "\r",
          "    outputStream.Append(v0);\r",
          "    outputStream.Append(v1);\r",
          "    outputStream.Append(v2);\r",
          "    */\r",
          "    \r",
          "    //float3 p0 = input[0].pos;\r",
          "    //float3 p1 = input[0].pos;\r",
          "\r",
          "\r",
          "    \r",
          "    for (int i = 0; i < 3; i++)\r",
          "\t{\r",
          "        Vertex vertex = input[i];\r",
          "        float4 p = vertex.pos;\r",
          "        //p.xyz+= Translate;\r",
          "        \r",
          "        // Distort\r",
          "        //_noiseTime = Push;\r",
          "        //_frequency = 1/Shrink;\r",
          "        float distance = length(p-Center);\r",
          "        \r",
          "        float3 noiseOffset = float3(getNoise((p.y+p.z) * NoiseScale + distance * Value - 6.3f), \r",
          "                                    getNoise((p.z+p.x) * NoiseScale + distance * Value - 9.3f), \r",
          "                                    getNoise((p.x+p.y) * NoiseScale + distance * Value - 0.3f));\r",
          "                                    \r",
          "        //p.x+= sin( noiseOffset.x * NoiseScale2) * noiseOffset.y * NoiseAmount;\r",
          "        //p.y+= sin( noiseOffset.y * NoiseScale2) * noiseOffset.y * NoiseAmount;\r",
          "        //p.z+= sin( noiseOffset.z * NoiseScale2) * noiseOffset.y * NoiseAmount;\r",
          "        //p.xyz += noiseOffset * NoiseAmount;\r",
          "        \r",
          "        \r",
          "        float angleX= (noiseOffset.z+noiseOffset.y)*  NoiseAmount +  NoiseScale2;\r",
          "        float cax= cos(angleX);\r",
          "        float sax= sin(angleX);    \r",
          "        float4x4 rotx = {    1,    0,    0,    0,\r",
          "                         0,    cax, -sax,  0,\r",
          "                         0,    sax,  cax,  0,\r",
          "                         0,    0,    0,    1};\r",
          "        //float angleY= influence * 3.141578 * Rotate/360 * getNoise(1233, seed);\r",
          "        float angleY= noiseOffset.x * NoiseAmount + NoiseScale2 ;\r",
          "        float cay= cos(angleY);\r",
          "        float say= sin(angleY);    \r",
          "        float4x4 roty = {    cay,  0,    say,  0,\r",
          "                         0,    1,    0,    0,\r",
          "                        -say,  0,    cay,  0,\r",
          "                         0,    0,    0,    1};\r",
          "        float4x4 rotation = mul(rotx,roty);\r",
          "\r",
          "\r",
          "    float4x4 translateToOrigin ={ 1,    0,    0,   Center.x,\r",
          "                             0,    1,    0,   -Center.y,\r",
          "                             0,    0,    1,   -Center.z,\r",
          "                             0,    0,    0,   1};\r",
          "\r",
          "    float4x4 translateBack={  1,    0,    0,   Center.x,\r",
          "                             0,    1,    0,    Center.y,\r",
          "                             0,    0,    1,    Center.z,\r",
          "                             0,    0,    0,   1};\r",
          "        \r",
          "        float4x4 transform = mul( rotation, translateToOrigin);\r",
          "        transform = mul( translateBack, transform);\r",
          "\r",
          "        p = mul(transform, p); \r",
          "        \r",
          "        /*        \r",
          "        if(Shrink !=0) {\r",
          "            float shrinkScale = influence * Shrink;\r",
          "            p.xyz+= (pCenter-p)*shrinkScale;\r",
          "        }\r",
          "        */\r",
          "    \r",
          "        //float pushStrength = Distort * getNoise(seed, i) ;\r",
          "\r",
          "        //p.xyz+= direction/distance * influence * pushStrength  ; \r",
          "        //p = mul(transform, p);        \r",
          "        \r",
          "        vertex.pos.xyz = p.xyz;\r",
          "        //vertex.normal = mul( float4(vertex.normal.xyz,1), rotation);\r",
          "        \r",
          "        outputStream.Append(vertex);\r",
          "    }\r",
          "    \r",
          "    outputStream.RestartStrip();\r",
          "};\r",
          "\r",
          "\r",
          "GeometryShader pGSComp = CompileShader(gs_5_0, GeometryMain());\r",
          "GeometryShader pGSwSO = ConstructGSWithSO(pGSComp, \"POSITION; NORMAL.xyz; COLOR; TEXCOORD0.xy; TANGENT0.xyz; BINORMAL0.xyz\", NULL, NULL, NULL, 0);\r",
          "\r",
          "\r",
          "technique11 Render\r",
          "{\r",
          "    pass \r",
          "    {\r",
          "        SetVertexShader(CompileShader(vs_5_0, VertexMain()));\r",
          "        SetGeometryShader(pGSwSO);\r",
          "        SetPixelShader(NULL);\r",
          "    }\r",
          "}\r",
          "\r",
          ""
        ]
      },
      "MetaID": "c522a66e-3260-4692-b3e3-79fd0361fa3d",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Scene",
      "MetaInstanceID": "7d8569a5-b8e5-460f-95fe-448ae3c6636a",
      "DefaultValue": {
        "Type": "Scene",
        "Value": "Framefield.Core.Scene"
      },
      "MetaID": "79122951-7bc4-4c68-b085-866eab828248",
      "IsMultiInput": "False",
      "Relevance": "Required",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Value",
      "MetaInstanceID": "89a88501-619c-4f69-9147-dbb4646cb798",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Center.X",
      "MetaInstanceID": "18ddc8ce-7f90-444f-ba55-4d757e305416",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-10000",
      "Max": "10000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Center.Y",
      "MetaInstanceID": "afac0a9b-1100-48bd-9a24-68d6580707fd",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-10000",
      "Max": "10000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "Center.Z",
      "MetaInstanceID": "149c895a-2d84-4828-8e14-ed38ed3e51c0",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-10000",
      "Max": "10000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "NoiseTime",
      "MetaInstanceID": "d137e618-b2fb-4077-b316-92b0446055a9",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "NoiseAmount",
      "MetaInstanceID": "2c63812d-76d3-4846-9d67-1edae879e128",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "NoiseScale",
      "MetaInstanceID": "7ff70aba-d976-434d-9f3b-8fc01b31b1b7",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    },
    {
      "Name": "NoiseScale2",
      "MetaInstanceID": "44e223eb-29c7-43de-9c71-e3b72b53938e",
      "DefaultValue": {
        "Type": "Float",
        "Value": "0"
      },
      "MetaID": "3f76dee3-3897-44ac-82d6-25ce9f53a506",
      "IsMultiInput": "False",
      "Relevance": "Optional",
      "Description": "",
      "Min": "-100000",
      "Max": "100000",
      "Scale": "0.1",
      "ScaleType": "Linear",
      "EnumValues": []
    }
  ],
  "Outputs": [
    {
      "Name": "Scene",
      "MetaInstanceID": "764ebcf0-02f3-4a3c-987a-8cb8cd3aabd7",
      "MetaID": "79122951-7bc4-4c68-b085-866eab828248"
    }
  ],
  "OperatorParts": [
    {
      "MetaInstanceID": "d71b4759-efd8-4c2c-83d5-61a68cd76660",
      "MetaID": "04e27ce1-fc64-4bf7-b71a-3d3c164542e1",
      "Name": "TwirlDistortFunc",
      "Version": "0f873e2b-be54-4d7c-bf03-8d71b6a9dd7e",
      "Type": "Float",
      "IsMultiInput": "True",
      "Script": [
        "//>>> _using",
        "using System;",
        "using System.Collections.Generic;",
        "using System.Linq;",
        "using System.Text;",
        "using SharpDX;",
        "using SharpDX.Direct3D11;",
        "using SharpDX.Windows;",
        "//<<< _using",
        "using Framefield.Core.OperatorPartTraits;",
        "using Framefield.Core.Rendering;",
        "using Buffer = SharpDX.Direct3D11.Buffer;",
        "using SharpDX.Direct3D;",
        "",
        "namespace Framefield.Core.ID04e27ce1_fc64_4bf7_b71a_3d3c164542e1",
        "{",
        "    public class Class_TwirlDistort : FXSourceCodeFunction, IFXSceneSourceCode, IMeshSupplier",
        "    {",
        "        //>>> _inputids",
        "        private enum InputId",
        "        {",
        "            Code = 0,",
        "            Scene = 1,",
        "            Value = 2,",
        "            CenterX = 3,",
        "            CenterY = 4,",
        "            CenterZ = 5,",
        "            NoiseTime = 6,",
        "            NoiseAmount = 7,",
        "            NoiseScale = 8,",
        "            NoiseScale2 = 9",
        "        }",
        "        //<<< _inputids",
        "",
        "        public Class_TwirlDistort()",
        "        {",
        "            _meshCollector = new MeshCollector(this);",
        "        }",
        "",
        "        public override void Dispose() ",
        "        {",
        "            Utilities.DisposeObj(ref _mesh);",
        "            base.Dispose();",
        "        }",
        "",
        "        public void AddMeshesTo(ICollection<Mesh> meshes)",
        "        {",
        "            UpdateMesh(new OperatorPartContext(), OperatorPart.Connections);",
        "            if (_mesh != null)",
        "                meshes.Add(_mesh);",
        "        }",
        "",
        "        public override OperatorPartContext Eval(OperatorPartContext context, List<OperatorPart> inputs, int outputIdx)",
        "        {",
        "            try",
        "            {",
        "                UpdateMesh(context, inputs);",
        "",
        "                if (_mesh.Vertices != null)",
        "                {",
        "                    // render stream output to screen or whatever target is set",
        "                    context.Renderer.SetupEffect(context);",
        "                    context.Renderer.Render(_mesh, context);",
        "                }",
        "            }",
        "            catch (Exception exception)",
        "            {",
        "                Logger.Error(this, \"Load Effect error: {0}\", exception.Message);",
        "            }",
        "",
        "            return context;",
        "        }",
        "",
        "        bool _firstEval = true;",
        "        private void UpdateMesh(OperatorPartContext context, List<OperatorPart> inputs)",
        "        {",
        "            if (_firstEval)",
        "            {",
        "                for (int i = 0; i < NumCodes(); ++i)",
        "                    Compile(i);",
        "                _firstEval = false;",
        "                Changed = true;",
        "            }",
        "",
        "            if (!Changed && _mesh.Vertices != null)",
        "                return;",
        "",
        "            //>>> _params",
        "            var Code = inputs[(int)InputId.Code].Eval(context).Text;",
        "            var Scene = inputs[(int)InputId.Scene];",
        "            var Value = inputs[(int)InputId.Value].Eval(context).Value;",
        "            var CenterX = inputs[(int)InputId.CenterX].Eval(context).Value;",
        "            var CenterY = inputs[(int)InputId.CenterY].Eval(context).Value;",
        "            var CenterZ = inputs[(int)InputId.CenterZ].Eval(context).Value;",
        "            var Center = new Vector3(CenterX, CenterY, CenterZ);",
        "            var NoiseTime = inputs[(int)InputId.NoiseTime].Eval(context).Value;",
        "            var NoiseAmount = inputs[(int)InputId.NoiseAmount].Eval(context).Value;",
        "            var NoiseScale = inputs[(int)InputId.NoiseScale].Eval(context).Value;",
        "            var NoiseScale2 = inputs[(int)InputId.NoiseScale2].Eval(context).Value;",
        "            //<<< _params",
        "",
        "            if (Scene.Func.Changed || _mesh.Vertices == null)",
        "            {",
        "                //Logger.Info(this, \"collect meshes\");",
        "                _meshCollector.Collect(Scene);",
        "                Scene.Func.Changed = false;",
        "            }",
        "",
        "            var inputMesh = _meshCollector.FirstMeshOrDefault;",
        "            if (inputMesh == null)",
        "                return;",
        "",
        "            _mesh.AttributesSize = inputMesh.AttributesSize;",
        "            _mesh.NumTriangles = inputMesh.NumTriangles;",
        "            _mesh.InputElements = inputMesh.InputElements;",
        "            if (_mesh.Vertices == null || _mesh.Vertices.Description.SizeInBytes != inputMesh.Vertices.Description.SizeInBytes)",
        "            {",
        "                if (_mesh.Vertices != null)",
        "                    _mesh.Vertices.Dispose();",
        "",
        "                _mesh.Vertices = new Buffer(D3DDevice.Device, new BufferDescription()",
        "                                                                    {",
        "                                                                        BindFlags = BindFlags.StreamOutput | BindFlags.VertexBuffer,",
        "                                                                        CpuAccessFlags = CpuAccessFlags.None,",
        "                                                                        OptionFlags = ResourceOptionFlags.None,",
        "                                                                        SizeInBytes = _mesh.NumTriangles*inputMesh.AttributesSize*3,",
        "                                                                        Usage = ResourceUsage.Default",
        "                                                                    });",
        "            }",
        "",
        "            _effect.GetVariableByName(\"Value\").AsScalar().Set(Value);",
        "            _effect.GetVariableByName(\"Center\").AsVector().Set(new Vector3(CenterX, CenterY, CenterZ));",
        "            //_effect.GetVariableByName(\"Translate\").AsVector().Set(new Vector3(TranslateX, TranslateY, TranslateZ));",
        "            //_effect.GetVariableByName(\"Range\").AsVector().Set(new Vector(RangeSize, RangeFallOff));",
        "            _effect.GetVariableByName(\"NoiseTime\").AsScalar().Set(NoiseTime);",
        "            _effect.GetVariableByName(\"NoiseAmount\").AsScalar().Set(NoiseAmount);",
        "            _effect.GetVariableByName(\"NoiseScale\").AsScalar().Set(NoiseScale);",
        "            _effect.GetVariableByName(\"NoiseScale2\").AsScalar().Set(NoiseScale2);",
        "            //_effect.GetVariableByName(\"Distort\").AsScalar().Set(Distort);",
        "            //_effect.GetVariableByName(\"Rotate\").AsScalar().Set(Rotate);",
        "",
        "            context.D3DDevice.ImmediateContext.StreamOutput.SetTargets(new [] { new StreamOutputBufferBinding(_mesh.Vertices, 0) });",
        "            context.D3DDevice.ImmediateContext.OutputMerger.DepthStencilState = new DepthStencilState(context.D3DDevice,",
        "                                                                                                        new DepthStencilStateDescription()",
        "                                                                                                            {",
        "                                                                                                                IsDepthEnabled = false,",
        "                                                                                                                IsStencilEnabled = false",
        "                                                                                                            });",
        "            context.D3DDevice.ImmediateContext.InputAssembler.InputLayout = context.InputLayout;",
        "            context.D3DDevice.ImmediateContext.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;",
        "            context.D3DDevice.ImmediateContext.InputAssembler.SetVertexBuffers(0, new VertexBufferBinding(inputMesh.Vertices, inputMesh.AttributesSize, 0));",
        "            var technique = _effect.GetTechniqueByIndex(0);",
        "            technique.GetPassByIndex(0).Apply(context.D3DDevice.ImmediateContext);",
        "            context.D3DDevice.ImmediateContext.Draw(_mesh.NumTriangles*3, 0);",
        "            context.D3DDevice.ImmediateContext.StreamOutput.SetTargets(new [] { new StreamOutputBufferBinding(null, 0) });",
        "",
        "            Changed = false;",
        "        }",
        "",
        "        private Mesh _mesh = new Mesh();",
        "        private MeshCollector _meshCollector;",
        "    }",
        "}",
        "",
        "",
        ""
      ],
      "AdditionalAssemblies": []
    }
  ],
  "Operators": [],
  "Connections": [
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "764ebcf0-02f3-4a3c-987a-8cb8cd3aabd7"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "00b8b4d9-f0a4-4b07-9c19-018a4358c1f6",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "7d8569a5-b8e5-460f-95fe-448ae3c6636a",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "89a88501-619c-4f69-9147-dbb4646cb798",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "18ddc8ce-7f90-444f-ba55-4d757e305416",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "afac0a9b-1100-48bd-9a24-68d6580707fd",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "149c895a-2d84-4828-8e14-ed38ed3e51c0",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "d137e618-b2fb-4077-b316-92b0446055a9",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "2c63812d-76d3-4846-9d67-1edae879e128",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "7ff70aba-d976-434d-9f3b-8fc01b31b1b7",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    },
    {
      "SourceOp": "00000000-0000-0000-0000-000000000000",
      "SourceOpPart": "44e223eb-29c7-43de-9c71-e3b72b53938e",
      "TargetOp": "00000000-0000-0000-0000-000000000000",
      "TargetOpPart": "d71b4759-efd8-4c2c-83d5-61a68cd76660"
    }
  ]
}